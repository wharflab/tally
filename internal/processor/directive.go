package processor

import (
	"path/filepath"

	"github.com/tinovyatkin/tally/internal/directive"
	"github.com/tinovyatkin/tally/internal/rules"
)

// InlineDirectiveFilter applies inline ignore directives.
// Supports # tally ignore=..., # hadolint ignore=..., and # check=skip=...
//
// This processor collects additional violations for:
//   - Parse errors in directives
//   - Unused directives (if WarnUnused is enabled)
//   - Missing reason= (if RequireReason is enabled)
//
// NOTE: This processor is stateful - it stores additional violations that must
// be retrieved via AdditionalViolations() after Process() completes. The state
// is reset on each Process() call, making it safe for sequential reuse but not
// for concurrent or multi-pass processing.
type InlineDirectiveFilter struct {
	// additionalViolations collects directive-related warnings.
	// Reset on each Process() call.
	additionalViolations []rules.Violation

	// registry is used to validate rule codes
	registry *rules.Registry
}

// NewInlineDirectiveFilter creates a new inline directive filter processor.
func NewInlineDirectiveFilter() *InlineDirectiveFilter {
	return &InlineDirectiveFilter{
		registry: rules.DefaultRegistry(),
	}
}

// Name returns the processor's identifier.
func (p *InlineDirectiveFilter) Name() string {
	return "inline-directive-filter"
}

// Process applies inline directives to filter violations.
// Also collects additional violations for invalid/unused directives.
func (p *InlineDirectiveFilter) Process(
	violations []rules.Violation,
	ctx *Context,
) []rules.Violation {
	// Reset additional violations for each run
	p.additionalViolations = nil

	// Check if any file has inline directives enabled
	// (we need to process each file to check its config)
	if ctx.DefaultConfig != nil && !ctx.DefaultConfig.InlineDirectives.Enabled {
		// Quick check: if default config has directives disabled and no per-file configs,
		// we can skip processing entirely
		if len(ctx.FileConfigs) == 0 {
			return violations
		}
	}

	// Group violations by file for efficient processing
	// Normalize paths for cross-platform compatibility (Windows uses backslashes)
	// but preserve the canonical path for ConfigForFile lookup
	type fileBucket struct {
		path       string
		violations []rules.Violation
	}
	byFile := make(map[string]*fileBucket)
	for _, v := range violations {
		normalized := filepath.ToSlash(v.Location.File)
		bucket := byFile[normalized]
		if bucket == nil {
			bucket = &fileBucket{path: v.Location.File}
			byFile[normalized] = bucket
		}
		bucket.violations = append(bucket.violations, v)
	}

	// Also include files from FileSources that have no violations
	// (they may still have unused directives or directives without reasons)
	for file := range ctx.FileSources {
		normalized := filepath.ToSlash(file)
		bucket := byFile[normalized]
		if bucket == nil {
			byFile[normalized] = &fileBucket{path: file}
		} else if bucket.path == "" {
			bucket.path = file
		}
	}

	// Process each file
	result := make([]rules.Violation, 0, len(violations))
	for _, bucket := range byFile {
		filtered := p.processFile(bucket.path, bucket.violations, ctx)
		result = append(result, filtered...)
	}

	return result
}

// AdditionalViolations returns violations generated by the directive processor.
// These include parse errors, unused directives, and missing reasons.
// Call this after Process() to get all directive-related warnings.
// Returns a defensive copy to prevent external mutation of internal state.
func (p *InlineDirectiveFilter) AdditionalViolations() []rules.Violation {
	return append([]rules.Violation(nil), p.additionalViolations...)
}

// processFile processes inline directives for a single file.
func (p *InlineDirectiveFilter) processFile(
	file string,
	violations []rules.Violation,
	ctx *Context,
) []rules.Violation {
	// Get config for this specific file
	cfg := ctx.ConfigForFile(file)
	if cfg == nil {
		return violations
	}

	// Skip if inline directives are disabled for this file
	if !cfg.InlineDirectives.Enabled {
		return violations
	}

	sm := ctx.GetSourceMap(file)
	if sm == nil {
		return violations
	}

	// Set up rule validator if configured
	var validator directive.RuleValidator
	if cfg.InlineDirectives.ValidateRules {
		validator = p.registry.Has
	}

	// Parse directives
	directiveResult := directive.Parse(sm, validator)

	// Report parse errors as warnings
	for _, parseErr := range directiveResult.Errors {
		p.additionalViolations = append(p.additionalViolations, rules.NewViolation(
			rules.NewLineLocation(file, parseErr.Line+1),
			"invalid-ignore-directive",
			parseErr.Message,
			rules.SeverityWarning,
		).WithDetail("Directive: "+parseErr.RawText))
	}

	// Filter violations based on directives
	if len(directiveResult.Directives) > 0 {
		filterResult := directive.Filter(violations, directiveResult.Directives)
		violations = filterResult.Violations

		// Report unused directives if configured
		if cfg.InlineDirectives.WarnUnused {
			for _, unused := range filterResult.UnusedDirectives {
				p.additionalViolations = append(p.additionalViolations, rules.NewViolation(
					rules.NewLineLocation(file, unused.Line+1),
					"unused-ignore-directive",
					"ignore directive does not suppress any violations",
					rules.SeverityWarning,
				).WithDetail("Directive: "+unused.RawText))
			}
		}
	}

	// Report directives without reason if configured
	if cfg.InlineDirectives.RequireReason {
		for _, d := range directiveResult.Directives {
			if d.Source != directive.SourceBuildx && d.Reason == "" {
				p.additionalViolations = append(p.additionalViolations, rules.NewViolation(
					rules.NewLineLocation(file, d.Line+1),
					"missing-directive-reason",
					"ignore directive is missing reason= explanation",
					rules.SeverityWarning,
				).WithDetail("Directive: "+d.RawText))
			}
		}
	}

	return violations
}
